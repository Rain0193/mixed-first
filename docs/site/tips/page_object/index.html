<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Page Object/Page Factory - 自动化测试</title>
  

  <link rel="shortcut icon" href="../../img/favicon.ico">

  

  
  <link rel="stylesheet" href="../../css/fonts.css" type="text/css" />

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Page Object/Page Factory";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> 自动化测试</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">主页</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>QuickStart</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../webui_automation/project_structure/">项目结构和配置</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../steps/steps_configuration/">项目结构和配置－步骤</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../properties/properties_intro/">配置文件说明</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../selenium_in_a_wild_way/">WEB页面自动化-SELENIUM管理页面元素</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../webui_automation/webui_automation_quickstart/">WEB页面自动化-开始</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../webui_automation/webui_automation_realexample/">WEB页面自动化-真实用例</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../api_automation/APIAutomation/">API 自动化测试</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../api_automation/api_testing_qa/">API 自动化测试常见问题</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../activity_automation/activity_automation_defined_employees/">工作流测试之指定审批节点</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../activity_automation/activity_automation_dynamic/">工作流测试之动态审批节点</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>自动化测试模块介绍</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../intro/automation-purpose/">目的</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../intro/automation-framework-impl/">基本模块的作用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../webui_automation/self_defined_elements/">页面自动化-页面元素的使用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../webui_automation/element_handler/">页面自动化-页面元素方法查询</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../webui_automation/pageobject_codegenerator/">页面自动化-页面代码生成</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../webui_automation/build_test/">页面自动化-WebTestActionBuilder</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>接口自动化测试</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../api_automation/web接口测试/">接口测试－WEB接口常见的实现方法</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../api_automation/APIAutomation/">API 自动化测试</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../api_automation/API自动化测试-进阶/">API自动化测试-进阶</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Tips</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../WebTest_Debug/">WebUI Debug</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../find_by_ref/">FindByRef annotation  使用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../best_practice/verification_annotation/">verification 注解使用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../jmeter_basic/">JMeter使用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../best_practice/code_style/">JAVA 自动化测试代码规范</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../best_practice/simple_ui_case/">一个简单测试用例的自动化实例</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../database/Database/">数据库操作</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../testng-xml-configuration/">TestNG 测试XML配置</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../use_own_password/">使用自己的用户名和密码获取万能密码</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../JsonHelper/">JSON处理</a>
        
    </li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">Page Object/Page Factory</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#page-object">Page Object模式</a></li>
                
                    <li><a class="toctree-l4" href="#from-selenium-wiki">From Selenium Wiki</a></li>
                
            
            </ul>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../TreeElement/">TreeElement 使用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../WebDriverHelper/">添加了Expectation的WebDriver操作</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../WebDriver操作/">WebDriver原生操作</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../how_to_write_teststeps/">编写测试步骤的不同方法</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../repeatable_elements/">重复填写控件使用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../StateElementReferneceException/">StateElementReferneceException</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../DateHelper/">DateHelper</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../database_assetion/">数据库验证</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../database_update/">预设条件数据的更新和回滚</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../testng_faq/">TestNG测试常见问题</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../simplest_testngreport/">TestNG 定制报表简单原理</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../PageFactory/">Page Factory 模式原理</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../random_data/">随机数据</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../data_construct_by_context/">动态测试数据构建</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../code_review_1/">代码检查-重复数据库访问</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Git</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../git/git_basic/">Git 基础</a>
        
    </li>

        
    </ul>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">自动化测试</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Tips &raquo;</li>
        
      
    
    <li>Page Object/Page Factory</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="page-object">Page Object模式</h1>
<p>关于Page Object模式可以参考一下Wiki:</p>
<ul>
<li><a href="https://code.google.com/p/selenium/wiki/PageObjects">Page Object 模式</a></li>
<li><a href="https://code.google.com/p/selenium/wiki/PageFactory">Page Factory</a></li>
</ul>
<p>关于这两个方式，总结一下就是：
- Page Object 模式用来管理页面元素,避免一些元素散落在代码各处，一旦页面发生变化，代码维护就变得异常困难和繁琐
- Page Factory，只要是一种创建PageObject的方式,实际上页面元素通过Proxy方式创建的;这是一种比较灵活的思路，定制化Page Factory的方式创建元素可以控制创建元素，可以加入自定义的方法</p>
<h2 id="from-selenium-wiki">From Selenium Wiki</h2>
<ul>
<li>Page Object </li>
</ul>
<pre><code>Page Objects
Within your web app's UI there are areas that your tests interact with. A Page Object simply models these as objects within the test code. This reduces the amount of duplicated code and means that if the UI changes, the fix need only be applied in one place.

Implementation Notes
PageObjects can be thought of as facing in two directions simultaneously. Facing towards the developer of a test, they represent the services offered by a particular page. Facing away from the developer, they should be the only thing that has a deep knowledge of the structure of the HTML of a page (or part of a page) It's simplest to think of the methods on a Page Object as offering the &quot;services&quot; that a page offers rather than exposing the details and mechanics of the page. As an example, think of the inbox of any web-based email system. Amongst the services that it offers are typically the ability to compose a new email, to choose to read a single email, and to list the subject lines of the emails in the inbox. How these are implemented shouldn't matter to the test.

Because we're encouraging the developer of a test to try and think about the services that they're interacting with rather than the implementation, PageObjects should seldom expose the underlying WebDriver instance. To facilitate this, methods on the PageObject should return other PageObjects. This means that we can effectively model the user's journey through our application. It also means that should the way that pages relate to one another change (like when the login page asks the user to change their password the first time they log into a service, when it previously didn't do that) simply changing the appropriate method's signature will cause the tests to fail to compile. Put another way, we can tell which tests would fail without needing to run them when we change the relationship between pages and reflect this in the PageObjects.

One consequence of this approach is that it may be necessary to model (for example) both a successful and unsuccessful login, or a click could have a different result depending on the state of the app. When this happens, it is common to have multiple methods on the PageObject:

public class LoginPage {
    public HomePage loginAs(String username, String password) {
        // ... clever magic happens here
    }

    public LoginPage loginAsExpectingError(String username, String password) {
        //  ... failed login here, maybe because one or both of the username and password are wrong
    }

    public String getErrorMessage() {
        // So we can verify that the correct error is shown
    }
}
The code presented above shows an important point: the tests, not the PageObjects, should be responsible for making assertions about the state of a page. For example:

public void testMessagesAreReadOrUnread() {
    Inbox inbox = new Inbox(driver);
    inbox.assertMessageWithSubjectIsUnread(&quot;I like cheese&quot;);
    inbox.assertMessageWithSubjectIsNotUnread(&quot;I'm not fond of tofu&quot;);
}
could be re-written as:

public void testMessagesAreReadOrUnread() {
    Inbox inbox = new Inbox(driver);
    assertTrue(inbox.isMessageWithSubjectIsUnread(&quot;I like cheese&quot;));
    assertFalse(inbox.isMessageWithSubjectIsUnread(&quot;I'm not fond of tofu&quot;));
}
Of course, as with every guideline there are exceptions, and one that is commonly seen with PageObjects is to check that the WebDriver is on the correct page when we instantiate the PageObject. This is done in the example below.

Finally, a PageObject need not represent an entire page. It may represent a section that appears many times within a site or page, such as site navigation. The essential principle is that there is only one place in your test suite with knowledge of the structure of the HTML of a particular (part of a) page.

Summary
The public methods represent the services that the page offers
Try not to expose the internals of the page
Generally don't make assertions
Methods return other PageObjects
Need not represent an entire page
Different results for the same action are modelled as different methods
Example
public class LoginPage {
    private final WebDriver driver;

    public LoginPage(WebDriver driver) {
        this.driver = driver;

        // Check that we're on the right page.
        if (!&quot;Login&quot;.equals(driver.getTitle())) {
            // Alternatively, we could navigate to the login page, perhaps logging out first
            throw new IllegalStateException(&quot;This is not the login page&quot;);
        }
    }

    // The login page contains several HTML elements that will be represented as WebElements.
    // The locators for these elements should only be defined once.
        By usernameLocator = By.id(&quot;username&quot;);
        By passwordLocator = By.id(&quot;passwd&quot;);
        By loginButtonLocator = By.id(&quot;login&quot;);

    // The login page allows the user to type their username into the username field
    public LoginPage typeUsername(String username) {
        // This is the only place that &quot;knows&quot; how to enter a username
        driver.findElement(usernameLocator).sendKeys(username);

        // Return the current page object as this action doesn't navigate to a page represented by another PageObject
        return this;    
    }

    // The login page allows the user to type their password into the password field
    public LoginPage typePassword(String password) {
        // This is the only place that &quot;knows&quot; how to enter a password
        driver.findElement(passwordLocator).sendKeys(password);

        // Return the current page object as this action doesn't navigate to a page represented by another PageObject
        return this;    
    }

    // The login page allows the user to submit the login form
    public HomePage submitLogin() {
        // This is the only place that submits the login form and expects the destination to be the home page.
        // A seperate method should be created for the instance of clicking login whilst expecting a login failure. 
        driver.findElement(loginButtonLocator).submit();

        // Return a new page object representing the destination. Should the login page ever
        // go somewhere else (for example, a legal disclaimer) then changing the method signature
        // for this method will mean that all tests that rely on this behaviour won't compile.
        return new HomePage(driver);    
    }

    // The login page allows the user to submit the login form knowing that an invalid username and / or password were entered
    public LoginPage submitLoginExpectingFailure() {
        // This is the only place that submits the login form and expects the destination to be the login page due to login failure.
        driver.findElement(loginButtonLocator).submit();

        // Return a new page object representing the destination. Should the user ever be navigated to the home page after submiting a login with credentials 
        // expected to fail login, the script will fail when it attempts to instantiate the LoginPage PageObject.
        return new LoginPage(driver);   
    }

    // Conceptually, the login page offers the user the service of being able to &quot;log into&quot;
    // the application using a user name and password. 
    public HomePage loginAs(String username, String password) {
        // The PageObject methods that enter username, password &amp; submit login have already defined and should not be repeated here.
        typeUsername(username);
        typePassword(password);
        return submitLogin();
    }
}
Support in WebDriver
There is a PageFactory in the support package that provides support for this pattern, and helps to remove some boiler-plate code from your Page Objects at the same time.

</code></pre>

<ul>
<li>Page Factory</li>
</ul>
<pre><code>The PageFactory
In order to support the PageObject pattern, WebDriver's support library contains a factory class.

A Simple Example
In order to use the PageFactory, first declare some fields on a PageObject that are WebElements or List&lt;WebElement&gt;, for example:

package org.openqa.selenium.example;

import org.openqa.selenium.WebElement;

public class GoogleSearchPage {
    // Here's the element
    private WebElement q;

    public void searchFor(String text) {
        // And here we use it. Note that it looks like we've
        // not properly instantiated it yet....
        q.sendKeys(text);
        q.submit();
    }
} 
In order for this code to work and not throw a NullPointerException because the &quot;q&quot; field isn't instantiated, we need to initialise the PageObject:

package org.openqa.selenium.example;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;
import org.openqa.selenium.support.PageFactory;

public class UsingGoogleSearchPage {
    public static void main(String[] args) {
        // Create a new instance of a driver
        WebDriver driver = new HtmlUnitDriver();

        // Navigate to the right place
        driver.get(&quot;http://www.google.com/&quot;);

        // Create a new instance of the search page class
        // and initialise any WebElement fields in it.
        GoogleSearchPage page = PageFactory.initElements(driver, GoogleSearchPage.class);

        // And now do the search.
        page.searchFor(&quot;Cheese&quot;);
    }
} 
Explanation
The PageFactory relies on using sensible defaults: the name of the field in the Java class is assumed to be the &quot;id&quot; or &quot;name&quot; of the element on the HTML page. That is, in the example above, the line:

    q.sendKeys(text);
is equivalent to:

    driver.findElement(By.id(&quot;q&quot;)).sendKeys(text);
The driver instance that's used is the one that's passed to the PageFactory's initElements method.

In the example given, we rely on the PageFactory to instantiate the instance of the PageObject. It does this by first looking for a constructor that takes &quot;WebDriver&quot; as its sole argument (public SomePage(WebDriver driver) {). If this is not present, then the default constructor is called. Sometimes, however, the PageObject depends on more than just an instance of the WebDriver interface. Should this be the case, it is possible to get the PageFactory to initialise the elements of an already constructed object:

ComplexPageObject page = new ComplexPageObject(&quot;expected title&quot;, driver);

// Note, we still need to pass in an instance of driver for the 
// initialised elements to use
PageFactory.initElements(driver, page);
Making the Example Work Using Annotations
When we run the example, the PageFactory will search for an element on the page that matches the field name of the WebElement in the class. It does this by first looking for an element with a matching ID attribute. If this fails, the PageFactory falls back to searching for an element by the value of its &quot;name&quot; attribute.

Although the code works, someone who's not familiar with the source of the Google home page may not know that the name of the field is &quot;q&quot;. Fortunately, we can pick a meaningful name and change the strategy used to look the element up using an annotation:

package org.openqa.selenium.example;

import org.openqa.selenium.By;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.How;
import org.openqa.selenium.WebElement;

public class GoogleSearchPage {
    // The element is now looked up using the name attribute
    @FindBy(how = How.NAME, using = &quot;q&quot;)
    private WebElement searchBox;

    public void searchFor(String text) {
        // We continue using the element just as before
        searchBox.sendKeys(text);
        searchBox.submit();
    }
} 
One wrinkle that remains is that every time we call a method on the WebElement, the driver will go and find it on the current page again. In an AJAX-heavy application this is what you would like to happen, but in the case of the Google search page we know that the element is always going to be there and won't change. We also know that we won't be navigating away from the page and returning (which would mean that a different element with the same name would be present) It would be handy if we could &quot;cache&quot; the element once we'd looked it up:

package org.openqa.selenium.example;

import org.openqa.selenium.By;
import org.openqa.selenium.support.CacheLookup;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.How;
import org.openqa.selenium.WebElement;

public class GoogleSearchPage {
    // The element is now looked up using the name attribute,
    // and we never look it up once it has been used the first time
    @FindBy(how = How.NAME, using = &quot;q&quot;)
    @CacheLookup
    private WebElement searchBox;

    public void searchFor(String text) {
        // We continue using the element just as before
        searchBox.sendKeys(text);
        searchBox.submit();
    }
} 
Reducing Verbosity
The example above is still a little verbose. A slightly cleaner way of annotating the field would be:

public class GoogleSearchPage {
  @FindBy(name = &quot;q&quot;)
  private WebElement searchBox;

  // The rest of the class is unchanged.
}
Notes
If you use the PageFactory, you can assume that the fields are initialised. If you don't use the PageFactory, then NullPointerExceptions will be thrown if you make the assumption that the fields are already initialised.
List&lt;WebElement&gt; fields are decorated if and only if they have @FindBy or @FindBys annotation. Default search strategy &quot;by id or name&quot; that works for WebElement fields is hardly suitable for lists because it is rare to have several elements with the same id or name on a page.
WebElements are evaluated lazily. That is, if you never use a WebElement field in a PageObject, there will never be a call to &quot;findElement&quot; for it.
The functionality works using dynamic proxies. This means that you shouldn't expect a WebElement to be a particular subclass, even if you know the type of the driver. For example, if you are using the HtmlUnitDriver, you shouldn't expect the WebElement field to be initialised with an instance of HtmlUnitWebElement.
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../TreeElement/" class="btn btn-neutral float-right" title="TreeElement 使用"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../JsonHelper/" class="btn btn-neutral" title="JSON处理"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../JsonHelper/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../TreeElement/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
